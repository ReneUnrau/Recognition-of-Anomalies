}
)
setMethod("generalize", signature(t = "TracksCollection"),
function(t, FUN = mean, ...) {
t@tracksCollection = lapply(t@tracksCollection,
function(x) generalize(x, FUN, ...))
t
}
)
```
---------------------
## 2. `cut` and `rle`
The first two generalize methods are for durations (`timeInterval`) and
distances, both of which use the `cut` and `rle` functions.
```{r trajectories-cut-rle, eval=FALSE}
generalize.Track <- function(t, FUN = mean, ..., timeInterval, distance, n, tol, toPoints) {
if(!missing(timeInterval)) {
origin = index(t@time)
cut = cut(origin, timeInterval)
segmentLengths = rle(as.numeric(cut))$lengths
}
if (!missing(distance)) {
# Total distances from each point to the first one.
origin = c(0, cumsum(t@connections$distance))
cut = floor(origin / distance)
segmentLengths = rle(cut)$lengths
}
}
```
Consider the first example of time. `t@time` is just a monotonic index of
trajectory times.
```{r}
tt <- cumsum (runif (100))
plot (1:length (tt), tt, "l", col="red")
cut <- cut (tt, 10)
rle (as.numeric (cut))
segmentLengths <- rle (as.numeric (cut))$lengths
```
---
## Exercise#1
* What is `sum (segmentLengths)`?
<span style="color:green"; font-size:2em>
Answers to exercise go here
</span>
* Describe in words what `cut` and `rle` do.
<span style="color:green"; font-size:2em>
cut: function is used to devide the data into equal intervals of the chosen attribute.
</br>
rle: counts the accurence of same values following one after another.
</span>
* Modify the above code to examine the effects of `cut` and `rle` for distances
from the origin, where these distances are not necessarily monotonically
increasing.
* (Extra exercise) Explain briefly what `generalize (t, n=x)` does
---
<span style="color:green"; font-size:2em>
Answers to exercise go here
</span>
-----------------
Make a sample track
```{r trackExample}
npts <- 10
xy <- array (runif (npts * 2) * 10, dim=c(npts, 2))
plot (xy)
points (head (xy,n=1), pch=19, col="blue", cex=2)
points (tail (xy,n=1), pch=19, col="green", cex=2)
indx1 <- 1:(npts - 1)
indx2 <- indx1 + 1
arrows (xy[indx1,1], xy[indx1,2], xy[indx2,1], xy[indx2,2], col="red")
```
Then store it as a `Track` object
```{r trackAsTrack, message=FALSE}
require (rgdal)
require (trajectories)
require (spacetime)
t0 <- as.POSIXct (as.Date (Sys.Date (), tz="CET"))
t <- t0 + cumsum (runif (npts) * 3600)
crs <- CRS ("+proj=longlat")
stidf <- STIDF (SpatialPoints (xy, crs), t, data.frame(extraDat=rnorm(npts)))
tr <- Track (stidf)
plot (tr)
```
Then make `tr` into a `tracksCollection` (because the `trajectories` plot method
at the moment only applies to `tracksCollection`, not `Tracks` or `Track`).
```{r tracksAsTracksCollection, fig.width=10}
makeTrack <- function (npts=10) {
require (rgdal)
crs <- CRS ("+proj=longlat")
xy <- array (runif (npts * 2) * 10, dim=c(npts, 2))
t0 <- as.POSIXct (as.Date (Sys.Date (), tz="CET"))
t <- t0 + cumsum (runif (npts) * 3600)
stidf <- STIDF (SpatialPoints (xy, crs), t, data.frame(extraDat=rnorm(npts)))
Track (stidf)
}
trcol <- TracksCollection (list (trs=Tracks (list (tr=makeTrack (20)))))
dim (trcol)
stplot (trcol, attr="duration", arrows=T, lwd=2, scales=list(draw=TRUE))
stplot (trcol, attr="extraDat", arrows=T, lwd=2, scales=list(draw=TRUE))
```
--------
## Exercise#2
* What other attributes can be plotted with `stplot`?
---
<span style="color:green"; font-size:2em>
Answer here
</span>
-----
Plotting of trajectories using the `stplot` routine is a work in progress, and
has several shortcomings, so it's easier to work with our own plot routine.
(This one only plots a single track.)
```{r trplot}
trplot <- function(x, y, ..., type = 'l', xlim = stbox(x)[,1],
ylim = stbox(x)[,2], col = 1, lwd = 1, lty =
1, axes = TRUE, Arrows = FALSE, Segments = FALSE, add = FALSE) {
if (class (x) == "TracksCollection") {
sp <- x@tracksCollection[[1]]@tracks[[1]]@sp
print("x class is: TracksCollection")
}
else if (class (x) == "Tracks") {
sp <- x@tracks [[1]]@sp
print("x class is: Tracks")
}
else sp <- tr@sp
aplot <- function (..., length, angle, code) plot (...)
if (! add)
aplot(as(sp, "Spatial"), xlim = xlim, ylim = ylim, axes = axes, ...)
if (axes == FALSE) box()
if (Arrows || Segments) {
df = as(x, "segments")
args = list(x0 = df$x0, y0 = df$y0, x1 = df$x1, y1 = df$y1,
col = col, lwd = lwd, lty = lty, ...)
if (Arrows) do.call(arrows, args)
else do.call(segments, args)
} else {
df = as(x, "data.frame")
cn = coordnames(x)
lines(df[[cn[1]]], df[[cn[2]]], col = col,
lwd = lwd, lty = lty, ...)
}
}
mytrplot <- function (x) {
trplot (x, Arrows=T, col="red", length=0.1, lwd=2)
xy <- SpatialPoints (x)
points (head (xy) [1], pch=19, col="blue", cex=2)
points (tail (xy, n=1), pch=19, col="green", cex=2)
}
mytrplot (trcol)
```
Then finally demonstrate the effects of various kinds of aggregation using `stplot`
```{r plotTrackAggregation, fig.width=10}
tra <- generalize (trcol, max, timeInterval="10 min")
mytrplot (trcol)
trplot (tra, add=TRUE, col="blue", lty=2, lwd=2)
tra <- generalize (trcol, max, n=5)
mytrplot (trcol)
trplot (tra, add=TRUE, col="blue", lty=2, lwd=2)
tra <- generalize (trcol, max, distance=1000000)
mytrplot (trcol)
trplot (tra, add=TRUE, col="blue", lty=2, lwd=2)
```
--------
## Exercise#3
* Why are the `distances` of `trcol` so enormous?
---
<span style="color:green"; font-size:2em>
Answer here
</span>
-----
## Better ways to aggregate trajectories
Extract `gpx-tracks.rar` and store them in a "dat" folder (or change the
following code accordingly).  These trajectories come from Holger Fritze, and
are GPS traces of him either running or cycling.
```{r gpx}
require (plotKML)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
dim (tr)
trplot (tr, col="red", lwd=1, attr="ele")
```
Then just to illustrate the kinds of problems that this course might contribute
to overcoming. The function `stplot` is from Edzer's
[`spacetime`](https://github.com/edzer/spacetime) package, and yet obviously has
some issues.
```{r}
require(spacetime)
#stplot (tr, lwd=1, attr="speed")
```
## Issue#1
* Try to fix this problem with `stplot`
------
## Loading several trajectories
```{r gpxs, eval=FALSE}
getTr <- function (file) {
tr <- readGPX (file)
tr <- tr$tracks[[1]][[1]]
crs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
stidf <- STIDF (sp, t, data.frame (tr$ele))
as (stidf, "Track")
}
ddir <- "dat/gpx-tracks/"
files <- list.files (ddir)
files <- as.character (sapply (files, function (x) paste (ddir, x, sep="")))
runs <- rides <- list ()
for (f in files) {
cat (f, "\n")
tr <- getTr (f)
if (length (grep ("Running", f)) > 0) runs <- c (runs, tr)
else rides <- c (rides, tr)
}
holger <- TracksCollection (list (runs=Tracks (runs), rides=Tracks (rides)))
plot (holger, col="red", lwd=1)
```
Some of my cycling trajectories are in `gpx-tracks-mp.tar.gz`. Extract these
tracks, load and plot. Note that the time format of mine is slightly different
because it has milliseconds, which requires changing the `getTr` function
```{r, eval=FALSE}
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%OSZ"))
```
source()
```{r, eval=FALSE}
ddir <- "/dat/gpx-tracks-mp/"
files <- list.files
files <- as.character (sapply (files, function (x) paste (ddir, x, sep="")))
rides <- list ()
for (f in files) {
cat (f, "\n")
rides <- c (rides, getTr (f))
}
mark <- TracksCollection (list (rides=Tracks (rides)))
plot (mark, col="blue", lwd=1)
```
--------
## Homework
* Use trajectory aggregation to describe how Holger's cycling differs from mine
* Comparisons can be qualitative (visual) or quantitative (numeric)
## OR
* Extend the above `trplot` function to plot `Tracks` and `TracksCollection`
objects.
* or extend the `stplot` routine
## OR
* Devise a `summary` function for `Tracks` and `TracksCollections` objects
---
<span style="color:green"; font-size:2em>
Answer here
</span>
-----
# create Tracks obj
tracks1 = Tracks(tracks=list(list (tr1=makeTrack (20), tr2=makeTrack (20))))
tracks2 = Tracks(tracks=list(list (tr1=makeTrack (20), tr2=makeTrack (20))))
# create TracksCollection obj
trackscollection1 = TracksCollection (list (trs1=tracks1, trs2=tracks2))
tracks1 = Tracks(tracks=list(tr1=makeTrack (20), tr2=makeTrack (20)))
tracks2 = Tracks(tracks=list(tr1=makeTrack (20), tr2=makeTrack (20)))
# create TracksCollection obj
trackscollection1 = TracksCollection (list (trs1=tracks1, trs2=tracks2))
tracks1@tracks
# create Tracks obj
tracks1 = Tracks(tracks=list(tr1=makeTrack (10), tr2=makeTrack (10)))
tracks2 = Tracks(tracks=list(tr1=makeTrack (10), tr2=makeTrack (10)))
# create TracksCollection obj
trackscollection1 = TracksCollection (list (trs1=tracks1, trs2=tracks2))
tracks1@tracks
tracks1@tracks$tr1@data$extraDat
tracks1@tracks$tr1@data
tracks1@tracks$tr1
require (plotKML)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
dim (tr)
trplot (tr, col="red", lwd=1, attr="ele")
files
tr
summary(tr)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr[[1]]
tr$tracks
test = tr$tracks
test[1]
summary(test)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
test
head(test)
# MARK
ddir_m <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks-mp/"
files <- list.files (ddir_m)
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
tr_m <- tr$tracks[[1]][[1]]
tr_m
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
tr_m
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
tr_m
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
tr_m$tracks
summary(tr_m$tracks)
summary(tr_m)
summary(tr_m$metadata)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
summary(tr)
tr <- tr$tracks[[1]][[1]]
summary(tr)
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
dim (tr)
trplot (tr, col="red", lwd=1, attr="ele")
summary(tr)
tr@time
ddir_m <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks-mp/"
files <- list.files (ddir_m)
slotNames(tr_m)
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
slotNames(tr_m)
names(tr_m)
tracks = tr_m$tracks
names(tracks)
slotNames(tracks)
str(tracks)
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
?generalize
type(tr)
class(tr)
ddir_m <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks-mp/"
files <- list.files (ddir_m)
tr_m <- readGPX (paste (ddir_m, files [1], sep=""), metadata = FALSE)
tr_m <- tr$tracks[[1]][[1]]
tr_m
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
dim (tr)
trplot (tr, col="red", lwd=1, attr="ele")
summary(tr)
generalize(tr, FUN=mean)
generalize(tr, FUN=mean, n=2)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
summary(tr)
test = generalize(tr, FUN=mean, n=2)
test = generalize(tr, FUN=mean, time="10 min")
test = generalize(tr, FUN=mean, n=50)
test
test@time
test@data
test@time
summary(test)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
summary(tr)
test = generalize(tr, FUN=mean, n=50)
summary(test)
test = generalize(tr, n=50)
summary(test)
ddir <- "C:/Users/Lars/Dropbox/Master/aot/lec2/dat/gpx-tracks/"
files <- list.files (ddir)
tr <- readGPX (paste (ddir, files [1], sep=""), metadata = FALSE)
tr <- tr$tracks[[1]][[1]]
trcrs <- CRS ("+proj=longlat")
sp <- SpatialPoints (tr[,1:2], crs)
t <- as.POSIXct(strptime(tr$time, "%Y-%m-%dT%H:%M:%SZ"))
tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
summary(tr)
test = generalize(tr, n=50)
summary(test)
tr
slots(tr)
slot(tr)
slotNames(tr)
slotNames(tr)
summary(tr)
test = generalize(tr, n=50)
summary(test)
class(test)
class(tr)
summary(test)
test = generalize(tr)
test = generalize(tr, n=100)
summary(test)
str(test)
con = test@connections
summary(con)
con
tr_sum=tr <- Track (STIDF (sp, t, data.frame (tr$ele)))
tr_sum@connections@.Data
tr_sum@connections@.S3Class
tr_sum
str(tr_sum)
tr_sum@connections$speed
tr_sum=summary(tr)
tr_sum$connections@.S3Class
tr_sum$connections
tr_sum$connections$speed
tr_sum$connections["speed"]
tr_sum$connections
tr_sum$connections
install.packages("signal")
?spec.pgram
ts_100 = rnorm(100)
spectrum(x=ts_100)
ts_1000 = rnorm(1000)
spectrum(x=ts_1000)
ts_10000 = rnorm(10000)
spectrum(x=ts_10000)
```{r}
wn_100 = rnorm(100)
spectrum(x=wn_100)
wn_1000 = rnorm(1000)
spectrum(x=wn_1000)
wn_10000 = rnorm(10000)
spectrum(x=wn_10000)
```
## Exercise 02
Compute the spectogram of a random walk process
```{r}
rw_100 = cumsum(wn_100)
spectrum(x=rw_100)
rw_1000 = rnorm(1000)
spectrum(x=rw_1000)
rw_10000 = rnorm(10000)
spectrum(x=rw_10000)
spectrum(x=rw_10000)
spectrum(x=rw_1000)
spectrum(x=wn_10000)
spectrum(x=rw_10000)
spectrum(x=wn_10000)
ar100 = arima.sim(n=100, list(ar=c(0.8)))
spectrum(x=ar100)
ar1000 = arima.sim(n=1000, list(ar=c(0.8)))
spectrum(x=ar1000)
ar10000 = arima.sim(n=10000, list(ar=c(0.8)))
spectrum(x=ar10000)
arn100 = arima.sim(n=100, list(ar=c(-0.8)))
spectrum(x=arn100)
arn1000 = arima.sim(n=1000, list(ar=c(-0.8)))
spectrum(x=arn1000)
arn10000 = arima.sim(n=10000, list(ar=c(-0.8)))
spectrum(x=arn10000)
# test to call function from another file
source("import.R")
require(rgdal)
require(RCurl)
require(RJSONIO)
require(stringr)
require(maptools)
tracksURL = "https://envirocar.org/api/stable"
trackID = "545aa4f4e4b0b53890a2e62c"
queryTracksCollection = importEnviroCar(tracksURL, trackID)
setwd("C:/Users/Lars/Dropbox/Master/Car/R")
# test to call function from another file
source("import.R")
require(rgdal)
require(RCurl)
require(RJSONIO)
require(stringr)
require(maptools)
tracksURL = "https://envirocar.org/api/stable"
trackID = "545aa4f4e4b0b53890a2e62c"
queryTracksCollection = importEnviroCar(tracksURL, trackID)
queryTracksCollection@tracksCollection$Tracks1@tracksData$medspeed
queryTracksCollection@tracksCollection$Tracks1@tracksData
queryTracksCollection@tracksCollection$Tracks1@tracks
queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@connections
head(queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@connections)
head(queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@data)
head(queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@sp)
head(queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@time)
head(queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@endTime)
queryPoints = queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@sp
queryPoints@coords
queryPoints@proj4string
plot(queryPoints@coords)
plot(queryPoints@coords, col="green")
setwd("C:/Users/Lars/Dropbox/Master/Car/R")
measurements = queryTracksCollection@tracksCollection$Tracks1@tracks$Track1@data
head(measurements)
